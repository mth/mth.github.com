<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<title>Yeti programming language</title>
</head><body>
<p>
<table width="100%" border=0><tr><td><h1>Yeti</h1></td>
<td align=right valign=top><small><i>... and the slime became the worm and the worm the serpent, <br>the serpent became the yeti of the mountain forests and the yeti became man.</i></small></td></tr></table>
</p>
Yeti is
<a href="http://en.wikipedia.org/wiki/ML_(programming_language)">ML style</a>
functional programming language, that runs on the
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">JVM</a>.
<ul>
<li>Binary jar archive: <a href="http://linux.ee/~mzz/yeti/yeti.jar">yeti.jar</a><br>
(occasionally updated and built from development snapshots)</li>
<li><a href="http://github.com/mth/yeti/tree/master">Source</a> is available through git and svn (ant is needed for building):<br>
<tt><b>git clone git://github.com/mth/yeti.git</b></tt><br>
<tt><b>svn co http://svn.github.com/mth/yeti.git</b></tt><br>
(BSD licensed)
</li>
<li>Read the <a href="http://linux.ee/~mzz/yeti/intro.html">tutorial</a> (also available as
<a href="http://linux.ee/~mzz/yeti/intro.pdf">PDF</a>).</li>
<li>Vim <a href="https://github.com/mth/yeti/raw/master/util/syntax/yeti.vim">syntax hilighting</a> and <a href="https://github.com/mth/yeti/raw/master/util/ftplugin/yeti.vim">filetype plugin</a>.<br>
Save these files as <tt>~/.vim/syntax/yeti.vim</tt> and
<tt>~/.vim/ftplugin/yeti.vim</tt> accordingly, and add<br>
<tt><b>au BufNewFile,BufRead *.yeti setlocal filetype=yeti ts=8 sw=4 sts=4 expandtab</b></tt><br>
into your <tt>~/.vimrc</tt>.</li>
<li><a href="http://chrisichris.wordpress.com/2011/02/26/yeti-editor-support-in-vim-netbeans-and-notepad/">Netbeans and Notepad++ support.</a></li>
<li><a href="https://github.com/mth/yeti/raw/master/util/syntax/yeti-mode.el">Emacs mode for Yeti</a>.</li>
<li>Help can be asked from the
<a href="http://groups.google.com/group/yeti-lang">mailing list</a>.
Please report any bugs you find.
</li>
</ul>
The goal of the Yeti is to have a clean and minimal expressive language on the JVM that allows functional style programming, has static type inference and interfaces well with Java code.
<p>
Some of the features:
<ul>
<li>Type inference using the Hindley-Milner algorithm. The types are
statically inferred at compile time without a need for explicit type
declarations.</li>
<li>Polymorphic <a href="http://linux.ee/~mzz/yeti/intro.html#structures">structure</a> and
<a href="http://linux.ee/~mzz/yeti/intro.html#variant-types">variant types</a>. Using those resembles
duck typing from the dynamic languages - for example, when a value is used as
a structure having a field foo, which gives string value, then any structure
with string field foo will be good enough.</li>
<li>Property fields in structures (access goes through function calls).</li>
<li><a href="http://linux.ee/~mzz/yeti/intro.html#lazy-lists">Lazy lists</a></li>
<li><a href="http://linux.ee/~mzz/yeti/intro.html#pattern-matching">Pattern matching on values</a></li>
<li>Comfortable string regex support
<li>Easy to <a href="http://linux.ee/~mzz/yeti/intro.html#using-java-classes-from-yeti-code">call existing Java code</a></li>
<li>Interactive <a href="http://linux.ee/~mzz/yeti/intro.html#interactive-evaluation">REPL environment</a> for experimenting</li>
<li>Compiles directly to Java bytecode</li>
<li>Fast compilation and quite fast execution</li>
</ul>
More information will be probably available at future - the language
is still in the development, but existing language syntax shouldn't change
anymore.
Standard library (especially the io module) needs work (and documentation).
It is quite usable already, but sure it contains undiscovered bugs.
There is also a plan to add <a href="http://github.com/mth/yeti/tree/master/doc/macros.rst">macro support</a>, but it isn't going to happen before
version 1.0 is released.
<h3>Updates...</h3>
9/2008. Some bugfixes here and there have happened (you can read the git log).
Java classes are probably next thing to be implemented
(actually the syntax is decided and parser support already exists).<p>
10/2008. <a href="http://linux.ee/~mzz/yeti/intro.html#defining-java-classes-in-yeti-code">Java class definitions</a> are
supported now. Additionally bunch of bugfixes and optimisations have been done.
<p>
12/2008. Some bugfixes and .[] can now be used for accessing Java array
elements too. Also added some smart auto-casting for Java arrays.
<p>
5/2009. Some bugfixes, allowed partial variant match in case,
recursive type definitions.
<p>
8/2009. Bugfixes, case pattern matching should work now better.
Mixed Java/Yeti build task enchasements.
<p>
4/2010. Bugfixes, like always. New features:<ul>
<li>Verify regex constants at compile time.</li>
<li>Thread-local variable support in standard library.</li>
<li>Invoking Yeti compiler from in-memory compiled Yeti code works now.</li>
<li>Multiple Java classes can be imported from a package using one import
statement (like <tt>import java.io: File, FileInputStream;</tt>).</li>
<li>Renamed asm3 library packages included in yeti.jar
(to avoid conflicts with other asm library usage).</li>
<li>Optimize functions into simple static methods,
if there are no other references than full application.</li>
<li>Mixed Yeti/Java source compilation in Yeti compiler,
supports circular references between Yeti and Java source files.</li>
</ul>
Better type mismatch error messages and documentation generation
from comments are partially implemented (means doesn't work yet).
<hr>
<p align="right"><img src="../any.gif">
<br><small>(put yeti into subject)</small></p>
</body>
</html>
